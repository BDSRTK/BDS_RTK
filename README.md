# BDS_RTK
GNSS一体机定位仓库
BDS（北斗）基站 - 流动站数据转发系统 算法设计文档
文档信息
项目项：文档名称 内容：BDS 基站 - 流动站数据转发系统算法设计文档
项目项：项目版本 内容：V1.0
项目项：开发语言 内容：C 语言（POSIX 标准兼容）
项目项：运行平台 内容：Linux 系统
项目项：最后更新 内容：2026-01-13
项目项：编写人员 内容：ClancyShang
1. 项目概述
1.1 项目背景与目标
本项目实现一套基于 TCP/IP 网络和串口通信的北斗（BDS）基站 - 流动站数据转发系统，核心目标是将基站通过串口获取的北斗原始数据，通过互联网可靠转发至流动站，再由流动站将数据写入本地串口，供北斗终端设备解析使用，同时提供简化版测试程序，用于快速验证网络通信链路的可用性。
1.2 系统整体功能
基站端：从指定串口（/dev/ttyS1）读取北斗原始数据，建立 TCP 客户端连接，将数据透传至流动站服务器。
流动站端：建立 TCP 服务器监听指定端口，接受基站连接，将接收到的网络数据透传至本地指定串口（/dev/ttyS1）。
测试程序：剥离串口依赖，基站测试程序直接发送固定测试数据，流动站测试程序接收数据并打印，快速验证网络通信的有效性。
辅助功能：基站端支持自动获取本地 IPv4 地址，便于排查网络配置问题。
1.3 设计原则
模块化设计：将串口初始化、网络连接、数据转发等功能拆分独立模块，提高代码可维护性和复用性。
实时性保障：采用串口原始模式和无缓冲读取配置，确保北斗数据的实时转发，无额外延迟。
可靠性优先：完善的异常处理（设备打开失败、连接异常、数据传输不完整等），及时释放系统资源。
POSIX 兼容性：使用标准 POSIX 接口（termios、socket、ifaddrs 等），确保在不同 Linux 发行版上的可移植性。
2. 总体架构设计
2.1 系统架构描述
基站端作为 TCP 客户端，包含串口模块、网络客户端模块、本地 IP 获取模块，串口模块读取北斗原始数据，网络客户端模块将数据发送至流动站；流动站端作为 TCP 服务器，包含串口模块、网络服务器模块，网络服务器模块接收基站数据，串口模块将数据写入本地串口。
测试程序分别为简化版的基站客户端和流动站服务器，无串口依赖，直接完成数据收发验证。
2.2 模块划分
2.2.1 公共模块（基站 / 流动站共用）
串口初始化模块：负责打开串口设备、配置串口参数、应用终端属性，提供统一的串口文件描述符。
Socket 基础模块：封装 TCP Socket 的创建、参数配置等基础操作，分为客户端 Socket（基站）和服务器端 Socket（流动站）。
2.2.2 基站端专属模块
本地 IP 获取模块：遍历系统网络接口，筛选有效非回环 IPv4 地址，支持指定网卡查询。
串口→网络数据转发模块：循环从串口读取数据，通过 TCP Socket 将数据转发至流动站服务器，处理数据传输异常。
基站主控制模块：串联各子模块，完成初始化、数据转发、资源释放的整体流程。
2.2.3 流动站端专属模块
网络→串口数据转发模块：接受基站 TCP 连接，循环接收网络数据，将数据写入本地串口，处理连接断开和传输异常。
流动站主控制模块：串联各子模块，维持服务器监听状态，持续处理基站连接和数据转发。
2.2.4 测试程序模块
基站测试模块：简化版网络客户端，直接发送固定测试数据 BASERTK_TEST，验证网络上行链路。
流动站测试模块：简化版网络服务器，接收测试数据并打印，验证网络下行链路。
3. 详细模块设计
3.1 公共模块设计
3.1.1 串口初始化模块（init_serial 函数）
功能描述：打开指定串口设备，配置符合北斗设备通信要求的串口参数，返回可用的串口文件描述符。
输入参数：const char *port（串口设备路径）、speed_t baud（串口波特率）。
输出参数：成功返回串口文件描述符（>0），失败返回 - 1。
实现步骤：
步骤 1：调用 open () 函数打开串口设备，参数为 O_RDWR | O_NOCTTY | O_NDELAY。
步骤 2：调用 tcgetattr () 函数获取当前串口的终端属性，存入 termios 结构体。
步骤 3：调用 cfsetispeed () 和 cfsetospeed () 函数，设置串口输入和输出波特率。
步骤 4：清除原有数据位掩码，设置为 8 位数据位（CS8）。
步骤 5：清除 CSTOPB 掩码，设置为 1 位停止位。
步骤 6：清除 PARENB 掩码，设置为无校验。
步骤 7：清除 CRTSCTS（硬件流控）、IXON/IXOFF/IXANY（软件流控）掩码，关闭流控。
步骤 8：关闭规范模式（ICANON）、回显（ECHO）、信号响应（ISIG），关闭输出处理（OPOST），配置为原始模式。
步骤 9：设置 VMIN=1（最少读取 1 字节返回）、VTIME=0（无超时等待），配置读取超时。
步骤 10：调用 tcsetattr () 函数（TCSANOW 参数），将修改后的终端属性写入串口。
步骤 11：验证各步骤返回值，异常时关闭串口并返回 - 1，成功则返回串口文件描述符。
关键参数：波特率 B115200，数据格式 8N1（8 位数据位、无校验、1 位停止位），工作模式为原始模式。
3.1.2 Socket 基础模块
3.1.2.1 客户端 Socket（基站 init_socket 函数）
功能描述：创建 TCP 客户端 Socket，连接至指定 IP 和端口的流动站服务器。
输入参数：const char *ip（流动站服务器 IP 地址）、int port（流动站服务器监听端口）。
输出参数：成功返回 Socket 描述符（>0），失败返回 - 1。
实现步骤：
步骤 1：调用 socket () 函数创建 TCP Socket，参数为 AF_INET | SOCK_STREAM | 0。
步骤 2：初始化 sockaddr_in 结构体，设置地址族为 AF_INET，端口转换为网络字节序（htons ()）。
步骤 3：调用 inet_pton () 函数将服务器 IP 地址从字符串转换为网络字节序，存入 sockaddr_in 结构体。
步骤 4：调用 connect () 函数建立与流动站服务器的 TCP 连接。
步骤 5：验证各步骤返回值，异常时关闭 Socket 并返回 - 1，成功则返回 Socket 描述符。
3.1.2.2 服务器端 Socket（流动站 init_server_socket 函数）
功能描述：创建 TCP 服务器 Socket，绑定指定端口并开始监听客户端连接。
输入参数：int port（服务器监听端口）。
输出参数：成功返回 Socket 描述符（>0），失败返回 - 1。
实现步骤：
步骤 1：调用 socket () 函数创建 TCP Socket，参数为 AF_INET | SOCK_STREAM | 0。
步骤 2：设置 SO_REUSEADDR 选项，允许端口复用，避免程序重启后端口占用问题。
步骤 3：初始化 sockaddr_in 结构体，设置地址族为 AF_INET，端口转换为网络字节序，绑定所有网卡（INADDR_ANY）。
步骤 4：调用 bind () 函数将 Socket 与指定端口绑定。
步骤 5：调用 listen () 函数开始监听，设置最大待处理连接数为 5。
步骤 6：验证各步骤返回值，异常时关闭 Socket 并返回 - 1，成功则返回 Socket 描述符。
3.2 基站端专属模块设计
3.2.1 本地 IP 获取模块（get_local_ip 函数）
功能描述：遍历系统所有网络接口，筛选有效 IPv4 地址，支持指定网卡查询，返回动态分配的 IP 字符串。
输入参数：const char *ifname（网卡名称，NULL 表示获取第一个可用非回环地址）。
输出参数：成功返回 IP 字符串（需手动释放内存），失败返回 NULL。
实现步骤：
步骤 1：调用 getifaddrs () 函数获取系统所有网络接口信息，返回接口链表头指针。
步骤 2：遍历接口链表，跳过空地址的接口。
步骤 3：筛选 AF_INET 类型的接口，调用 inet_ntop () 函数将网络字节序 IP 转换为字符串。
步骤 4：排除回环地址（127.0.0.1），若指定网卡名称则匹配对应接口。
步骤 5：找到有效 IP 后，调用 malloc () 分配内存，复制 IP 字符串并跳出遍历。
步骤 6：若未找到有效非回环地址，兜底返回回环地址（127.0.0.1）。
步骤 7：调用 freeifaddrs () 释放接口链表资源，验证内存分配结果，返回 IP 字符串或 NULL。
3.2.2 串口→网络数据转发模块（serial_to_network 函数）
功能描述：循环从串口读取数据，通过已建立的 TCP Socket 将数据透传至流动站，处理传输过程中的异常。
输入参数：int serial_fd（串口文件描述符）、int sock_fd（TCP Socket 描述符）。
实现步骤：
步骤 1：定义固定大小缓冲区（BUFFER_SIZE=1024），用于存储读取的串口数据。
步骤 2：进入无限循环，调用 read () 函数从串口读取数据，获取实际读取字节数。
步骤 3：若读取字节数 > 0：调用 send () 函数将缓冲区数据发送至流动站，验证发送字节数是否与读取字节数一致，不一致则打印警告。
步骤 4：若读取字节数 < 0：打印读取错误信息，跳出循环（终止转发）。
步骤 5：若读取字节数 = 0：无数据可读，继续循环等待。
3.2.3 基站主控制模块（main 函数）
实现步骤：
步骤 1：调用 get_local_ip () 函数获取本地 IP 地址，打印后释放内存。
步骤 2：调用 init_serial () 函数初始化串口，获取串口文件描述符，失败则退出程序。
步骤 3：调用 init_socket () 函数初始化 TCP 客户端，连接流动站服务器，失败则关闭串口并退出程序。
步骤 4：打印程序启动信息，调用 serial_to_network () 函数开始数据转发。
步骤 5：转发终止后，关闭串口和 Socket 描述符，释放系统资源。
3.3 流动站端专属模块设计
3.3.1 网络→串口数据转发模块（network_to_serial 函数）
功能描述：接受基站的 TCP 连接，循环接收网络数据，将数据写入本地串口，处理连接断开和传输异常。
输入参数：int sock_fd（服务器 Socket 描述符）、int serial_fd（串口文件描述符）。
实现步骤：
步骤 1：定义固定大小缓冲区（BUFFER_SIZE=1024），定义客户端地址结构体和长度。
步骤 2：调用 accept () 函数阻塞等待基站连接，获取客户端 Socket 描述符，失败则返回。
步骤 3：打印客户端 IP 和端口信息，进入无限循环处理数据。
步骤 4：调用 recv () 函数接收客户端数据，获取实际接收字节数。
步骤 5：若接收字节数 > 0：调用 write () 函数将缓冲区数据写入串口，验证写入字节数是否与接收字节数一致，不一致则打印警告。
步骤 6：若接收字节数 = 0：打印客户端断开信息，跳出循环（关闭当前客户端连接）。
步骤 7：若接收字节数 < 0：打印接收错误信息，跳出循环。
步骤 8：关闭客户端 Socket 描述符，释放资源。
3.3.2 流动站主控制模块（main 函数）
实现步骤：
步骤 1：调用 init_serial () 函数初始化串口，获取串口文件描述符，失败则退出程序。
步骤 2：调用 init_server_socket () 函数初始化 TCP 服务器，获取服务器 Socket 描述符，失败则关闭串口并退出程序。
步骤 3：打印程序启动信息，进入无限循环。
步骤 4：在循环中调用 network_to_serial () 函数，处理基站连接和数据转发，支持断开后重新等待新连接。
步骤 5：转发终止后，关闭串口和服务器 Socket 描述符，释放系统资源。
3.4 测试程序模块设计
3.4.1 基站测试程序（bds_base_test.c）
核心流程：
步骤 1：定义固定测试数据 "BASERTK_TEST"，计算数据长度。
步骤 2：调用 init_socket () 函数初始化 TCP 客户端，连接流动站测试程序。
步骤 3：调用 send () 函数发送测试数据，验证发送字节数是否完整。
步骤 4：打印发送成功信息，关闭 Socket 描述符，退出程序。
设计亮点：剥离串口依赖，快速验证网络上行链路，无需外接北斗设备。
3.4.2 流动站测试程序（bds_sove_test.c）
核心流程：
步骤 1：调用 init_server_socket () 函数初始化 TCP 服务器，监听指定端口。
步骤 2：调用 accept () 函数阻塞等待基站测试程序连接。
步骤 3：调用 recv () 函数接收测试数据，添加字符串结束符（'\0'）。
步骤 4：打印接收的数据内容和字节数，关闭客户端和服务器 Socket 描述符，退出程序。
设计亮点：剥离串口依赖，快速验证网络下行链路，直观查看传输结果。
4. 数据流程设计
4.1 正式运行场景（基站→流动站）
前置条件：流动站端先启动，完成串口和服务器 Socket 初始化，开始监听 8888 端口。
基站端启动，完成串口初始化，建立与流动站 8888 端口的 TCP 连接。
北斗设备向基站串口（/dev/ttyS1）写入原始数据。
基站端 serial_to_network () 函数调用 read () 读取串口数据至缓冲区。
基站端调用 send () 将缓冲区数据通过 TCP Socket 发送至流动站。
流动站端 accept () 接收到基站连接，创建客户端 Socket。
流动站端 network_to_serial () 函数调用 recv () 接收网络数据至缓冲区。
流动站端调用 write () 将缓冲区数据写入本地串口（/dev/ttyS1）。
流动站本地北斗终端设备从串口读取数据并解析。
重复步骤 3-9，直至任一程序退出或网络连接断开。
4.2 测试场景（基站测试程序→流动站测试程序）
前置条件：流动站测试程序先启动，完成服务器 Socket 初始化，监听 8888 端口。
基站测试程序启动，建立与流动站测试程序 8888 端口的 TCP 连接。
基站测试程序调用 send () 发送固定数据 "BASERTK_TEST"。
流动站测试程序 accept () 接收到连接，调用 recv () 接收数据。
流动站测试程序打印数据内容和字节数，程序退出。
基站测试程序打印发送成功信息，程序退出。
5. 异常处理设计
异常类型：串口打开失败
触发场景：init_serial () 中 open () 返回 < 0
处理方式：打印 perror 错误信息，返回 - 1，主程序退出
异常类型：串口属性配置失败
触发场景：init_serial () 中 tcgetattr ()/tcsetattr () 返回 < 0
处理方式：关闭已打开的串口，打印 perror 错误信息，返回 - 1，主程序退出
异常类型：Socket 创建失败
触发场景：init_socket ()/init_server_socket () 中 socket () 返回 < 0
处理方式：打印 perror 错误信息，返回 - 1，主程序退出
异常类型：TCP 连接失败
触发场景：基站 init_socket () 中 connect () 返回 < 0
处理方式：关闭 Socket，打印 perror 错误信息，返回 - 1，关闭串口后主程序退出
异常类型：端口绑定 / 监听失败
触发场景：流动站 init_server_socket () 中 bind ()/listen () 返回 < 0
处理方式：关闭 Socket，打印 perror 错误信息，返回 - 1，关闭串口后主程序退出
异常类型：串口读取失败
触发场景：serial_to_network () 中 read () 返回 < 0
处理方式：打印 perror 错误信息，跳出转发循环，关闭串口和 Socket
异常类型：网络发送 / 接收失败
触发场景：serial_to_network () 中 send () 返回 < 0、network_to_serial () 中 recv () 返回 < 0
处理方式：打印 perror 错误信息，跳出转发循环，关闭对应文件描述符
异常类型：数据传输不完整
触发场景：send ()/write () 返回字节数与待传输字节数不一致
处理方式：打印警告信息，不终止程序，继续后续传输
异常类型：客户端断开连接
触发场景：network_to_serial () 中 recv () 返回 0
处理方式：打印客户端断开信息，关闭客户端 Socket，返回主循环等待新连接
异常类型：本地 IP 获取失败
触发场景：get_local_ip () 中 getifaddrs () 返回 < 0 或 malloc () 失败
处理方式：打印 perror 错误信息，返回 NULL，主程序打印警告信息，不影响核心功能运行
6. 编译与运行说明
6.1 编译环境要求
Linux 操作系统（Ubuntu/CentOS 等）
GCC 编译器（版本 4.8 及以上）
无第三方依赖，仅依赖系统 POSIX 标准库
6.2 编译命令
基站测试程序
gcc bds_base_test.c -o bds_base_test
基站正式程序
gcc bds_base.c -o bds_base
流动站测试程序
gcc bds_sove_test.c -o bds_sove_test
流动站正式程序
gcc bds_sove.c -o bds_sove
6.3 运行步骤
测试场景
终端 1：启动流动站测试程序
./bds_sove_test
终端 2：启动基站测试程序
./bds_base_test
正式场景
终端 1：启动流动站正式程序（需 root 权限操作串口）
sudo ./bds_sove
终端 2：启动基站正式程序（需 root 权限操作串口）
sudo ./bds_base
6.4 注意事项
串口设备 /dev/ttyS1 需存在且有读写权限，可通过 ls /dev/ttyS1 验证，无权限可添加用户至 dialout 组或使用 sudo 运行
监听端口 8888 需未被其他程序占用，可通过 netstat -tulpn | grep 8888 验证
正式运行时需将 SERVER_IP 修改为流动站实际 IP 地址（非回环地址 127.0.0.1）
7. 总结与扩展建议
7.1 项目总结
本系统通过模块化设计实现了北斗基站 - 流动站的数据透传功能，满足了实时性和可靠性要求，测试程序可快速验证网络链路，降低了调试难度。系统基于 POSIX 标准接口开发，具有良好的可移植性，可直接部署在嵌入式 Linux 设备（如树莓派、STM32 Linux 开发板）上运行。
